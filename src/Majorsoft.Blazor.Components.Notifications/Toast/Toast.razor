@if (IsVisible)
{
    <AdvancedTimer Occurring="Times.Once()" DelayInMilisec="@_delay" IntervalInMilisec="@(Settings.AutoCloseInSec * 1000)" AutoStart="true"
                   OnIntervalElapsed="@(e => { IsVisible = false; })" />

    <div @ref="_inputRef" class="btoast-main@($" bnotify-{Settings.NotificationStyle.ToString().ToLower()}-{Settings.Type.ToString().ToLower()}")"
         style="opacity: @_opacity;
                margin-bottom: @(Settings.ShadowEffect + 12)px; 
                box-shadow: @($"{Settings.ShadowEffect / 4}px {Settings.ShadowEffect}px {(Settings.ShadowEffect == 0 ? "0" : "20")}px {Settings.ShadowEffect / 10}px") #c7c7c7;"
         tabindex="750">
        <div class="btoast-body">
            @if (Settings.ShowIcon)
            {
                <svg class="btoast-img" focusable="false" viewBox="0 0 24 24" aria-hidden="true">
                    <path fill-rule="evenodd" clip-rule="evenodd" d="@GetSvgPath()"></path>
                </svg>
            }

            <div class="btoast-text">
                @Settings.Content
            </div>

            @if (Settings.ShowCloseButton)
            {
                <button type="button" @onclick="CloseClicked" class="close@($" {Settings.NotificationStyle.ToString().ToLower()}")"><span aria-hidden="true">×</span><span class="sr-only">Close</span></button>
            }
        </div>
        @if (Settings.ShowCloseCountdownProgress && Settings.AutoCloseInSec > 0)
        {
            <div class="btoast-progress@((Settings.NotificationStyle != NotificationStyles.Strong ? $" {Settings.Type.ToString().ToLower()}" : " strong") + (_animationStarted ? " start" : ""))"
                 style="transition: width @(Settings.AutoCloseInSec)s linear;">
            </div>
        }
    </div>
}

@namespace Majorsoft.Blazor.Components.Notifications

@inject ILogger<Toast> _logger
@inject ITransitionEventsService _transitionEvents

@implements IAsyncDisposable

@code {
    private ElementReference _inputRef;
    /// <summary>
    /// Exposes a Blazor <see cref="ElementReference"/> of the wrapped around HTML element. It can be used e.g. for JS interop, etc.
    /// </summary>
    public ElementReference InnerElementReference => _inputRef;

    private byte _opacity = 1;

    private int _delay = 100;
    private bool _animationStarted = false;
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (Settings.ShowCloseCountdownProgress && IsVisible && !_animationStarted)
        {
            WriteDiag($"Rendered firstRender: '{firstRender}' _animationStarted: '{_animationStarted}'.");
            await Task.Delay(_delay);

            _animationStarted = true;
            StateHasChanged();
        }
    }

    private bool _isVisible = true;
    /// <summary>
    /// Determines wheatere the Toast message should be visible on UI or not.
    /// </summary>
    private bool IsVisible
    {
        get => _isVisible;
        set
        {
            if (value != _isVisible)
            {
                _opacity = 1;

                if (!value) //closing
                {
                    _transitionEvents.RegisterTransitionEndedAsync(_inputRef, async args =>
                    {
                        _isVisible = false;
                        _animationStarted = false;

                        StateHasChanged();

                        if (OnClose.HasDelegate)
                        {
                            await OnClose.InvokeAsync(Settings.Id);
                        }
                    }, "opacity");
                    _opacity = 0;
                }
                else //open
                {
                    if (OnOpen.HasDelegate)
                    {
                        InvokeAsync(async () =>
                        {
                            await OnOpen.InvokeAsync(Settings.Id);
                        });
                    }

                    _isVisible = true;
                }
            }
        }
    }

    /// <summary>
    ///
    /// </summary>
    [Parameter] public ToastSettings Settings { get; set; }


    //Events
    /// <summary>
    /// Callback function called when the Toast is opening.
    /// </summary>
    [Parameter] public EventCallback<Guid> OnOpen { get; set; }
    /// <summary>
    /// Callback function called when the Toast is closing.
    /// </summary>
    [Parameter] public EventCallback<Guid> OnClose { get; set; }
    /// <summary>
    /// Callback function called when close `x` button was clicked.
    /// </summary>
    [Parameter] public EventCallback<Guid> OnCloseButtonClicked { get; set; }


    private async Task CloseClicked(MouseEventArgs e)
    {
        if (Settings.ShowCloseButton)
        {
            WriteDiag($"Close button clicked Toast closing.");

            if (OnCloseButtonClicked.HasDelegate)
            {
                await OnCloseButtonClicked.InvokeAsync(Settings.Id);
            }

            IsVisible = false;
        }
    }

    private string GetSvgPath()
    {
        if (!string.IsNullOrWhiteSpace(Settings.CustomIconSvgPath))
        {
            return Settings.CustomIconSvgPath;
        }

        var property = typeof(NotificationTypes).GetMember(Settings.Type.ToString())[0];
        var attribute = property.GetCustomAttributes(typeof(NotificationTypesMetaData), true)[0];
        var description = (NotificationTypesMetaData)attribute;
        var path = description.IconSvgPath;

        return path;
    }

    public async ValueTask DisposeAsync()
    {
        if (_transitionEvents is not null)
        {
            await _transitionEvents.DisposeAsync();
        }
    }

    private void WriteDiag(string message)
    {
        _logger.LogDebug($"Component {this.GetType()}: {message}");
    }
}