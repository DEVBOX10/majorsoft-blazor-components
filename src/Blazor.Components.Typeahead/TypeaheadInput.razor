@using System.Linq
@using System.Text.RegularExpressions

@typeparam TItem;
@inject ILogger<TypeaheadInput<TItem>> _logger;

<DebounceInput class="typeahead"
	@ref="_typeahead"
	@bind-Value="@Value" @bind-Value:event="OnInput"
	DebounceTime="@DebounceTime"
	MinLength="@MinLength"
	OnValueChanged="e => OnValueChanged(e)"
	ForceNotifyByEnter="false"
	ForceNotifyOnBlur="false"
	@onblur="OnBlur" @onkeyup="OnKeyUp" @onfocus="OnFocus"
	@attributes=AdditionalAttributes />

@if(_isOpen && _data is not null) 
{
	_dropDownItems.Clear();
	int i = 0;
	<div class="dropdown-menu">
		<ul class="list">
			@foreach(var item in _data)
			{
				string text = GetItemText(item);
				string refName = $"item{i++}";

				<li @ref="_dropDownItems[refName]" class="list-item @(item.Equals(_activeItem) ? "active" : "")" 
					@onmouseover="_ => ItemHover(refName, item)"
					@onclick="_ => ItemClicked(refName, item)">
						@*@{
							if (CustomTemplate is not null)
								CustomTemplate(item);
							else
								HighlightItems(text);
						}*@
						@HighlightItems(text)
				</li>
			}
		</ul>
	</div>
}

@if(_hasNoResult) 
{
	<div class="no-result">@NoResultContent</div>
}

@if(_isSearching && InProgressContent is not null && !_isOpen) 
{
	<div class="no-result">@InProgressContent</div>
}

@code {
	protected override void OnAfterRender(bool firstRender)
	{
		if(!AdditionalAttributes.ContainsKey("autocomplete"))
		{
			AdditionalAttributes.Add("autocomplete", "off");
		}

		if(firstRender)
		{
			CheckRequiredPropertySelector();
		}
	}

	private bool _isOpen = false;
	private bool _hasNoResult = false;
	private bool _isSearching = false;
	private DebounceInput _typeahead;
	private IEnumerable<TItem> _data;

	private TItem _activeItem = default(TItem);
	private Dictionary<string, ElementReference> _dropDownItems = new Dictionary<string, ElementReference>();

	//Values
	private string _value;
	[Parameter] public string Value 
	{
		get => _value;
		set
		{
			if(value == _value)
			{
				return;
			}

			_value = value;
			if (OnInput.HasDelegate) //Immediately notify listeners of text change e.g. @bind
			{
				InvokeAsync(async () =>
				{
					await OnInput.InvokeAsync(_value);
				});
			}
		}
	}
	private TItem _selectedItem;
	[Parameter] public TItem SelectedItem 
	{
		get => _selectedItem;
		set
		{
			if(_selectedItem?.Equals(value) ?? false)
			{
				return;
			}

			_selectedItem = value;
			Value = GetItemText(_selectedItem);
			if (OnSelectedItemChanged.HasDelegate) //Immediately notify listeners for model selected
			{
				InvokeAsync(async () =>
				{
					await OnSelectedItemChanged.InvokeAsync(_selectedItem);
				});
			}
		}
	}

	//Data
	[Parameter] public IEnumerable<TItem> Data { get; set; } //Data for static values
	[Parameter] public Func<string, Task<IEnumerable<TItem>>> DataSource { get; set; } //Async Func to provide data
	[Parameter] public Func<TItem, string> LabelPropertySelector { get; set; } //When TItem is not string

	[Parameter] public bool SelectOnBlur { get; set; } = true;
	[Parameter] public bool ShowAllOnEmptyInput { get; set; } = true;

	//Size
	[Parameter] public double Height { get; set; } = 0;
	[Parameter] public double Width { get; set; } = 0;

	//Templates
	[Parameter] public RenderFragment<TItem> CustomTemplate { get; set; }
	[Parameter] public RenderFragment NoResultContent { get; set; }
	[Parameter] public RenderFragment InProgressContent { get; set; }

	//Debounce
	[Parameter] public double DebounceTime { get; set; } = 0;
	[Parameter] public int MinLength { get; set; } = 0;

	//Events
	[Parameter] public EventCallback<string> OnInput { get; set; }
	[Parameter] public EventCallback<TItem> OnSelectedItemChanged { get; set; }

	[Parameter(CaptureUnmatchedValues = true)]
	public Dictionary<string, object> AdditionalAttributes { get; set; }

	private async Task OnValueChanged(string value)
	{
		WriteDiag($"{nameof(OnValueChanged)} event new Value: '{value}, ShowAllOnEmptyInput: {ShowAllOnEmptyInput}'");

		_dropDownItems.Clear();

		if(string.IsNullOrEmpty(value))
		{
			if(DataSource is null && ShowAllOnEmptyInput)
			{
				WriteDiag($"{nameof(OnValueChanged)} event opening dropdown DataSource is NULL and ShowAllOnEmptyInput: {ShowAllOnEmptyInput}.");
				_data = Data;
				_isOpen = true;
				_activeItem = _data.First();

				return;
			}

			WriteDiag($"{nameof(OnValueChanged)} event closing dropdown.");
			_isOpen = false;
		}
		else
		{
			try
			{
				_isSearching = true;

				if (DataSource is not null) //Priority is async search
				{
					_data = await DataSource(value);
				}
				else if(Data is not null && typeof(TItem) == typeof(string))
				{
					_data = Data?
						.Cast<string>()
						.Where(x => x?.ToLower().Contains(value.ToLower()) ?? false)
						.Cast<TItem>();
				}
				else
				{
					_data = Data?.Where(x => LabelPropertySelector(x)?.ToLower().Contains(value.ToLower()) ?? false);
				}

				WriteDiag($"{nameof(OnValueChanged)} event filtered data count: '{_data?.Count()}' opening dropdown.");
				if(_data?.Count() > 0)
				{
					_isOpen = true;
					_hasNoResult = false;
					_activeItem = _data.First();
				}
				else
				{
					_isOpen = false;
					_hasNoResult = true;
				}
			}
			finally
			{
				_isSearching = false;
			}
		}
	}
	
	private async Task OnKeyUp(KeyboardEventArgs e)
	{
		WriteDiag($"OnKeyUp event: '{e.Key}'");
		if (e.Key?.Equals("Escape", StringComparison.OrdinalIgnoreCase) ?? false)
		{
			_isOpen = false;
		}
		else if (e.Key?.Equals("Enter", StringComparison.OrdinalIgnoreCase) ?? false)
		{
			if (_isOpen)
			{
				await ItemSelect(_activeItem);
			}
		}
		else if (e.Key?.Equals("ArrowDown", StringComparison.OrdinalIgnoreCase) ?? false)
		{
			if(_data is null || !_isOpen)
			{
				return;
			}

			var index = Array.IndexOf(_data.ToArray(), _activeItem);
			index++;
			if(index >= _data.Count())
			{
				index = 0;
			}

			_activeItem = _data.ElementAt(index);
		}
		else if (e.Key?.Equals("ArrowUp", StringComparison.OrdinalIgnoreCase) ?? false)
		{
			if(_data is null || !_isOpen)
			{
				return;
			}

			var index = Array.IndexOf(_data.ToArray(), _activeItem);
			index--;
			if(index < 0)
			{
				index = _data.Count() -1;
			}

			_activeItem = _data.ElementAt(index);
		}
	}
	private async Task OnBlur(FocusEventArgs e) //TODO: Should be replaced with ClickOutsideCheck
	{
		WriteDiag($"{nameof(OnBlur)} event: '{e.Type}'.");
		if(SelectOnBlur)
		{
			await ItemSelect(_activeItem);
		}
	}
	private async Task OnFocus(FocusEventArgs e)
	{
		WriteDiag($"{nameof(OnFocus)} event: '{e.Type}'.");
		if(DataSource is null && ShowAllOnEmptyInput)
		{
			WriteDiag($"{nameof(OnFocus)} event opening dropdown DataSource is NULL and ShowAllOnEmptyInput: {ShowAllOnEmptyInput}.");
			if (string.IsNullOrWhiteSpace(Value))
			{
				_data = Data;
				_isOpen = true;
				_activeItem = _data.First();
			}
			else
			{
				await OnValueChanged(Value);
			}
		}
	}

	private void ItemHover(string refName, TItem item)
	{
		WriteDiag($"{nameof(ItemHover)} event refName: {refName}, item: {item}.");
		_activeItem = item;
	}
	private async Task ItemClicked(string refName, TItem item)
	{
		WriteDiag($"{nameof(ItemClicked)} event refName: {refName}, item: {item}.");
		_activeItem = item;
		await ItemSelect(_activeItem);
	}

	private async Task ItemSelect(TItem item) //TODO: should select on Enter and active change with Arrow Keys
	{
		SelectedItem = item;
		Value = GetItemText(item);
		_isOpen = false;
		try
		{
			if(OnSelectedItemChanged.HasDelegate)
			{
				await OnSelectedItemChanged.InvokeAsync(item);
			}
		}
		finally {}
	}

	private bool IsLabelSelectorRequired() => typeof(TItem) != typeof(string);
	private bool IsDefaultSearchUsed() => Data is not null && DataSource is null;

	private void CheckRequiredPropertySelector()
	{
		if(IsLabelSelectorRequired() && LabelPropertySelector == null)
		{
			throw new Exception($"Data type: {typeof(TItem)} is not Sytem.String. You must provide a string property selector use {nameof(LabelPropertySelector)}");
		}
	}
	private MarkupString HighlightItems(string text)
	{
		if(IsDefaultSearchUsed() && !string.IsNullOrWhiteSpace(text) && !string.IsNullOrWhiteSpace(Value))
		{
			var pattern = $"({Value})";
			var regex = new Regex(pattern, RegexOptions.IgnoreCase | RegexOptions.Singleline);
			var replacement = "<strong>$0</strong>";

			var result = regex.Replace(text, replacement);
			return ((MarkupString)result);
		}
		
		return (MarkupString)(text ?? string.Empty);
	}
	private string GetItemText(TItem item)
	{
		string text = IsLabelSelectorRequired() && LabelPropertySelector is not null
			? LabelPropertySelector(item)
			: item.ToString();

		return text;
	}

	private void WriteDiag(string message)
	{
		_logger.LogDebug($"Component {this.GetType()}: {message}");
	}
}